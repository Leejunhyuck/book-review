- 문서 


    문서는 프로젝트 활동과 관련을 맺고 있어야 한다.

 

    Ubiquitous languzge언어로 작성하라

 

    문서를 최소한으로 유지하고 대화를 보완하는 데 집중하라

 

    문서는 유요한 상태를 유지하고 최신 내용을 담고 있어야 한다.

 

- 하나의 모델이 구현, 설계, 의사소통의 기초가 되야 한다

 

- 설명을 위한 모델!!

 

- 모델과 설계를 연계한는 것이 실용적이다.

 

- 소프트웨어 시스템의 일부를 설계할 때는 도메인 모델을 있는 그대로 반영해서 설계와 모델의 대응을 분명하게 하라. 또한 모델을 재검토해서 더욱 자연스럽게 소프트웨어로 구현될 수 있게 수정하라

 

- 유비쿼터스 언어를 지원하는 것과 더불어 분석과 설계의 두 가지 측면을 충분히 만족하는 단 하나의 모델을 만들어내야 한다.

 

- DDD에서는 모든 단일 컨텍스트 내에서 오로지 하나의 모델을 다룰 것을 요구한다.

 

- 코드의 변경이 곧 모델의 변경이다. 

 

- 도메인의 격리

    시스템에서 도메인과 관련이 적은 기능으로부터 도메인 객체를 분리할 필요가 있다. 이러한 기법을 Layered architecture(계층형 아키텍처) 이라고 한다.

 

    매우 복잡한 작업을 처리하는 소프트웨어를 만들 경우 관심사의 분리가 필요하며, 이로써 격리된 상태에 있는 각 설계 요소에 집중할 수 있다. 동시에 시스템 내의 정교한 상호작용은 

    그러한 분리와는 상관없이 유지돼야 한다.

 

    계층화의 핵심 원칙은 한 계층의 모든 요소는 오직 같은 계층에 존재하는 다른 요소나 계층상 '아래'에 위치한 요소에만 의존한다는것이다 위로 거슬러 올라가는 의사소통은 반드시 간적접인 메커니즘을 

    거처야 한다.

4가지 계층으로 이루어짐                                                                                                                  

    사용자 인터페이스 : 사용자에게 정보를 보여주고 사용자의 명령을 해석하는 일을 책임진다.

    응용계층 : 소프트웨어가 수행할 작업을 저으이하고 표현력 있는 도메인 객체가 문제를 해결하게 한다. 이 계층에서 책임지는 작업은 업무상 중요하거나 다른 시스템의 응용 계층과 상호작용하는데 필요한 것들이다.

    도메인 계층 : 업무 개념과 업무 상황에 관한 정보, 업무 규칙을 표현하는 일을 책임진다.

    인프라스트럭쳐 계층 상위 계층을 지원하는 일반화된 기술적 기능을 제공한다. 메시지 전송, 도메인 영속화, UI위젯을 그리는 것등 

 

    - 복잡한 프로그램을 여러 개의 계층으로 나누어라

    - 상위 계층과의 결합을 느슨하게 유지하라.

    - 도메인 객체는 도메인 모델을 표현하는 것에만 집중 할 수 있다.

    

- 계층 간 관계 설정

    각 계층은 설계 의존성을 오직 한 방향으로만 둬서 느슨하게 결합된다. 

    하위 수준의 객체가 상위 수준의 객체와 소통해야 할 경우 콜백이나 ovserver패턴처럼 계층 간에 관계를 맺어주는 아키텍처 패턴을 활욜 할 수 있다.

 

-smart ui 안티패턴

    모든 업무 로직을 사용자 인터페이스에 넣어라. 애플리케이션을 작은 기능으로 잘게 나누고, 나눈 기능을 각기 분리된 사용자 인터페이스로 구현해서 업무 규칙을 분리된 사용자 인터페이스에 들어가게 하라.

 

    단점 

        데이터 베이스를 이용하는 방식 말고는 여러 애플리케이션을 통합하기가 수월하지 않다.

        행위를 재사용하지 않으며 업무 문제에 대한 추상화가 이뤄지지 않는다. 업무 규칙이 적용 되는 연만사다 업무 규칙이 중복된다.

        신속한 프로토타입 작성과 반복주기가 smart ui가 지닌 태생적인 한계에 도달하게 된다. 이는 추상화의 부재로 리팩터링의 여지가 제한되기 때문이다.

        복잡성에 금방 압도되어 애플리케이션의 성장 경로가 순전히 부가적인 단순 응용으로만 향한다 우아한 방법으로 더욱 풍부한 행위를 갖출 수 있는 방법은 없다.

 

-연관관계를 줄여라(다루는 방법)

    1. 탐색 방향을 부여한다.

    2. 한정자를 추가해서 사실상 다중성을 줄인다.

    3. 중요하지 않은 연관관계를 제거한다.

 

- ENTITY

    - 자신의 생명주기 동안 형태와 내용이 급격하게 바뀔 수도 있지만 연속성은 유지해야한다.

    - 식별성이 저의돼 있어야 한다.

    - 사람,도시,자동차,복권티켓,은행거래 등

    ex) 경기장의 좌석을 예약하는 애플리케이션에서는 좌석과 참석자를 ENTITY로 다룰 수 있다 지정석인 경우 고유의 좌석번호가 적혀 있을 것이므로 좌석은 유일한 식별자를 갖는다.

        하지만, 입장권을 가진 사람이 빈 좌석을 찾아 아무 데나 앉을 수 있는 "일반석"이라면 개별좌석을 구분하지 않아도 된다. 이 경우 Entity가 아니며 식별자는 필요하지 않다.

 

    - 가장 기본적인 책임은 객체의 행위가 명확하고 예측 가능해질 수 있게 연속성을 확립하는 것이다.

 

- Value Object

    - ENTITY의 식별성을 관리하는 일은 매우 중요하지만 그 밖의 객체에 식별성을 추가한다면 시스템의 성능이 저하되고, 분석 작업이 별도로 필요하며, 모든 객체를 동일한 것으로 보이게 해서 모델이 혼란스러워질 수 있다.

    - 소프트웨어 설계는 복잡성과 끊임없는 전투다. 그러므로 우리는 특별하게 다뤄야 할 부분과 그렇지 않은 부분을 구분해야 한다.

    - 식별성이 없는 것으로만 생각한다면, 추가할 게 그리 많지 않다.

    - 즉, 사물을 서술하는 객체다.

    - 종종 한 연산에서 사용할 목적으로 만들어진 후 폐기되는 것처럼 일시적인 용도로 사용되기도 한다.

 

    모델에 포함된 어떤 요소의 속성에만 관심이 있다면 그것을 VALUE OBJECT로 분류하라.

    VALUE OBJECT는 불변적으로 다뤄라!

 

    ex) 한 객체가 다른 여러 객체에서 참조되고 있다면 그러한 객체 가운데 일부는 가까이에 위치하지 않을 것이므로 데이터를 가져오는 데 물리적인 연산이 추가적으로 필요할 것이다. (동일한 데이터에 여러 개의 사본을 저장하는 기법

    을 역정규화라고하며 접근 시간이 더 중요한 경우에 사용한다.)

 

- MODULE(모듈, 패키지라고 함)

    보통 module을 토대로 모델을 두 가지 측면에서 바라 볼 수 있다, 즉 사람들은 전체에 압도되지 않고도 세부사항을 보거나, 세부 사항을 배제한 상태에서 module 간의 관계를 볼 수 있다.

    모듈간의 결합도는 낮아야 하고 모듈간의 응집도는 높아야한다.(모듈로 쪼개지는 것은 코드가 아닌 개념이다)

    

    모듈은 모델과 함께 발전해야 한다. 

 

- Aggregate

    우리가 데이터 변경의 단위로 다루는 연관 객체의 묶음을 말한다. Aggregate에는 루트와 경계가 있다.

    경계는 Aggregate에 무엇이 포함되고 포함되지 않는지를 정의한다. 루트는 단 하나만 존재하며, Aggregate에 포함된 특정 ENTITY를 가리킨다.

    경계 안의 객체는 서로 참조 할 수 있지만, 경계 바깥의 객체는 해당 Aggregate의 구성요소 가운데 루트만 참조할 수 있다.

    루트 이외의 ENTITY는 지역 식별성을 지니며, 지역 식별성은 Aggregate 내에서만 구분되면 된다. 이는 해당 Aggregatedml 경계 밖에 위치한 객체는 루트 ENTITY의 컨텍스트 말고는 Aggregate의 내부를 볼 수 없기 때문이다.

 

    ENTITY와 VALUE OBJECT를 Aggregate로 모으고 각각에 대해 경계를 정의하라.

    한 ENTITY를 골라 Aggregate의 루트로 만들고 Aggregate 경계 내부의 객체에 데해서는 루트를 거쳐 접근할 수 있게 하라. Aggregate 밖의 객체는 루트만 참조할 수 있게 하라.

    내부 구성요소에 대한 일시적인 참조는 단일 연산에서만 사용할 목적에 한해 외부로 전달될 수 있다. 루트를 경유하지 않고는 Aggregate의 내부를 변경할 수 없다. 이런식으로 Aggregate의 각 요소를 배치하면 Aggregate 안의 객체와

    전체로서의  Aggregate의 상태를 변경할때 모든 불변식을 효과적으로 이행할 수 있다.

 

-FACTORY

    어떤 객체나 전체 Aggregate를 생성하는 일이 복잡해지거나 내부 구조를 너무 많이 드러내는 경우 FACTORY가 캡슐화를 제공해준다.

 

    복잡한 객체와 Aggregated의 인스턴스를 생성하는 책임을 별도의 객체로 옮겨라.

 

    FACTORY를 잘 설계학 위한 두가지 기본 요건

        1. 각 생성 방법은 원자적이어야 한다, 생성된 객체나 Aggregate의 불변식을 모두 지켜야 한다.

        2. 생성된 클래스보다는 생성하고자 하는 타입으로 추상화돼야 한다.

 

- 생성자만으로 충분한 경우

    클래스가 타입인 경우, 인터페이스를 구현하는 식으로 다형적으로 사용되지 않는 경우

    클라이언트가 strategy를 선택하는 한 방법으로서 구현체에 관심이 있는 경우

    클라이언트가 객체의 속성을 모두 이용할 수 있어서 클라이언트에게 노출된 생성자 내에서 객체 생성이 중첩되지 않는 경우

    생성자가 복잡하지 않은 경우

    공개 생성자가 FACTORY와 동일한 규칙을 반드시 준수해야 하는 경우, 이때 해당 규칙은 생성된 객체의 모든 불변식을 충족하는 원자적인 연산이어야 한다.
    
    - 인터페이스 설계
    
        각 연산은 원자적이어야한다.
    
        FACTORY는 자신에게 전달된 인자와 결합될 것이다. 입력 매개변수를 신경 써야한다. 아니면 의존성의 덫이 만들어질 수 있다.
    
     
    
     
    
    ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    
     
    
    - 명확한 모델을 발견하는 것이다.
    
     
    
    - 다소 불명확한 개념을 모델링 하는 법
    
        - 명시적인 제약조건
    
            흔히 제약조건은 암시적인 상태로 존재하며, 이를 명시적으로 표현하면 서계를 대폭 개선할 수 있다.
    
            (간단한 불변식의 경우에는 내용물을 변경하는 개별 연산 안에 조건 로직을 사용해서 불변식을 보장할 수 있다,)
    
            제약조건을 자체적인 메서드로 분리하면 제약조건에 이름을 부여해서 제약조건을 멱확하게 표현할 수 있다.
    
        - 도메인 객체로서의 프로세스
    
            알고리즘 자체 또는 그것의 일부를 하나의 객체로 만드는 것이다.
    
     
    
    -specification 
    
        다른 객체에 대한 제약조건을 기술하며, 제약조건은 존재할 수도 존재하지 않을 수도 있따.(또, 명시된 기준을 만족하는지 검사할 수 있다)
    
     
    
        매우 상이해 보이는 애플리케이션 기능을 하나로 통합해 준다.
    
        
    
        1. 객체가 어떤 요건을 충족시키거나 특정 목적으로 사용할 수 있는지 가늠하고자 객체를 검증
    
        2. 컬렉션 내의 객체를 선택
    
        3. 특정한 요구사항을 만족하는 새로운 객체의 생성을 명시
    
     
    
        1.검증  
    
        2.선택(또는 질의)   
    
        3.요청 구축 생성 (specification을 사용해서 생성기의 인터페이스를 정의하면 생성할 결과물을 명시적으로 인터페이스에 포함시킬 수 있따.)
    
            - 생성기의 구현을 인터페스로부터 분리할 수 있따. specification은 생성할 결과물에 대한 요구사항은 선언하지만 결과물을 생성하는 방법은 정의하지 않는다.
    
            - specification을 사용한 인터페이스는 생성 규칙을 명시적으로 전해주므로 개발자들이 연산의 세부적인 사항을 이해하지 않고도 생성기의 결과물을 예상할수있따.
    
            - 생성기는 단순히 specification에 포함된 조건에 따라 객체를 생성하는 반면 생성 요청을 표현하는 코드는 클아이언트에 존재하므로 더 유연한 인터페이스를 얻거나 더 유연하게 개선할 수 있따.
    
     
    
    유연한 설계를 만들 수 있는 패턴 집합
    
        -intention-revealing interface(의도를 드러내는 인터페이스)
    
            도메인 개념을 반영하도록 클래스와 메서드의 이름을 지어야 한다.
    
            결과와 목적만을 표현하도록 클래스와 연산의 이름을 부여하라
    
        -side-effect-free function(부수효과가 없는 함수)
    
            명령과 질의를 엄격하게 분리된 서로 다른 연산으로 유지하는 것이다.
    
            명령과 질의를 분리하는 대신 value Object를 생성해서 반환한다.
    
        -assertion
    
            assertion을 사용하면 명령 entity 부수효과가 명확해지고 다루기 쉬워진다.
    
        -conceptual contour(개념적 윤곽)
    
            도메인을 중요 영역을 나누는 것과 관련한 직관을 감안해서 설계요소를 응집력있는 단위로 분해해라. 계속적인 리팩터링을 토대로 변경되는 부분과 변경되지 않는 부분을 나누는 중심 축을 식별하고,
    
            변경을 분리하기 위한 패턴을 명확하게 표현하는 conceptual contour
    
        -standalone class(독립형 클래스)
    
            의존성을 낮춰야 함
    
            낮은 결합도는 객체 설계의 기본 원리다. 가능한 한 늘 결합도를 낮추고자 노력하라. 현재 싱황과 무관한 모든 개념을 제거하라. 그러면 클래스가 완전히 독립적으로 바뀌고 단독으로 컴토하고 이해할 수 있을 것이다.
    
        -closure of operation(연산의 닫힘)
    
            적절한 위치에 반환 타입과 인자 타입이 동일한 연산을 정의하라 구현자가 연산에 사용되는 상태를 포함하고 있다면 연산의 인자로 구현자를 사용하는 것이 효과적이므로 인자의 타입과 반환 타입을 구현자의 타입과 동일하게 정의한다.
    
            주로 VALUE OBJECT의 연산을 정의하는 데 주로 사용된다.
