
## 대용량 서비스를 지탱하는 기술
    
   책의 내용을 요약 및 정리합니다.

### CHAPTER 2 대규모 데이터 처리의 어려운 점

   * 데이터의 흐름 : 디스크에서 데이터를 로드해서 메모리에 저장, 메모리에 저장된 데이터를 cpu가 패치, 
    메모리에서 패치된 명령은 보다 빠른 캐시메모리에 캐싱된다  
      (디스크 -> 메모리 -> 캐시메모리 -> cpu)  각 단계별 속도에서는 차이가 많이 난다  
   * 대규모 데이터는 메모리 내에서 계산할 수 없다.
   * 디스크에 있는 데이터를 검색 -> 디스크는 느리다(약 10~100만배 정도 차이) I/O에 많은 시간이 걸린다.
   * 전송속도에서도 100배 이상 차이가 난다.
    
   부하는 크게 2가지로 분류된다  
   1. cpu 부하
        * 같은 구성의 서버를 늘리고 로드밸런서로 분산
        * 웹, AP 서버, 크롤러 등
   2. I/O 부하
        * DB
        * 대규모 데이터
    
### CHAPTER 3 OS캐시와 분산
    

### CHAPTER 4 DB 스케일아웃 전략
   * 분산을 고려한 MySQL운용의 포인트 
       1. OS 캐시의 활용
           * 전체 데이터 크기에 주의  
              -> 데이터량 < '물리 메모리' 를 유지  
              -> 메모미가 부족할 경우에는 증설
                  * int 32비트 : 4바이트, 문자열 8비트 -> 1바이트
            * 스키마 설계가 데이터 크기에 미치는 영향을 고려
       2. 인덱스를 적절하게 설정하기
       3. 확장을 전제로 한 설계
       
   * 인덱스의 중요성  
        * 인덱스 = 색인  
        * MySQL의 인덱스는 기본적으로 B+트리 이다.  
            - 외부기억장치 탐색 시에 seek 횟수를 최소화 하는 트리구조  
            - O(n) -> O(log n)  
        * 복수 칼럼에 동시에 인덱스를 태우고자 할 경우는 복합 인덱스를 사용해야만 한다.
        * explain 명령 속도에유의해서 보자

   * MySQL의 레플레이션 기능 
     * 마스터/슬레이브 구성
     * 참조 쿼리는 슬레이브로, 갱신 쿼리는 마스터로
     * O/R 매퍼로 제어한다.
   
   * 마스터/슬레이브의 특징  
     * 참조계열 쿼리는 확장
        - 서버를 늘리기만 하면 된다.
        - 단, 대수를 늘리기보다도 메모리에 맞추는 것이 중요
     * 마스터는 확장하지 않는다.
        - 갱신계열 쿼리가 늘어나면 험난해진다.
        - 단, 웹 애플리케이션은 대부분의 경우 90% 이상이 참조쿼리
        - 마스터 부하는 테이블 분할이나 다른 구현 등으로 연구
     * 마스터/슬레이브의 다중화
        - 기본은 4대가 1세트 (멀티 1대, 슬레이브 3대)
        - 멀티마스터
            - 상호간 레플리케이션
            - 전환 타이밍에 따라 동기가 맞지 않을 위험이 남아있다.   
                
       